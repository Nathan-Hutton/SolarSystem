- With input, we'll move the view matrix in a way that lets us move the camera around the world
- To handle movement, we just check for a change in the camera position. For glfw, use glfwGetKey(window, GLFW_KEY_W) for example
- SDL checks for an event then checks if it was a keydown event then checks which key was pressed
- glfw stores a map of all the key states, but SDL checks all the events individually.
- While the key is held, we add a value to the camera's position.
- To account for CPU speeds, we multiply by deltatime (Bethesda will never figure this out)

Types of angles for turning:
- Pitch: up and down
- Yaw: left and right
- roll: won't be using it but you can imagine what it means
- Pitching needs to rotate up and down relative to the axis of the yaw  
- Yaw will only ever rotate us around the y axis
- Don't need deltatime because the turning is based on the movement

For pitch:
- Pitch relies on an axis being rotated by yaw
- y = sin(pitch)
- x = cos(pitch)
- z = cos(pitch)

For yaw:
- Will only rotate us around the y axis, so we don't have to edit the y
- x = cos(yaw)
- y = sin(yaw)

Combining pitch and yaw:
- x = cos(pitch) * cos(yaw)
- y = sin(pitch)
- z = cos(pitch) * sin(yaw)
- The vector [x,y,z] will have the given pitch and yaw
- Update camera and direction with new vector

How we do this in code for rotations:
- GLFW: glfwSetCursorPosCallBack(window, callback) stores old mouse position, compare to new. Use difference to decide pitch/yaw change
- With GLFW, as soon as an event happens with the mouse, it'll call whatever function we've set as the callback function. We get new position from the callback function
- Whenever there's some change with the mouse, we store the new state, then when it happens again we get the new state, compare it to the old, then store the new one in place of the old
- Callback must be a static method
- SDL: Check SDL_MOUSEMOTION event. Call SDL_GetMouseState(&x, &y) then use difference to decide pitch/yaw change
- As soon as we've detected a SDL_MOUSEMOTION we cal SDL_GetMouseState.

Summary:
- View matrix requires position, direction, right, and up vectors. glm::lookAt handles this for us
- To move the camera, alter position on key press
- Use pitch and yaw to determine new direction vector
- Compare last and current mouse positions to determine changes in pitch and yaw
